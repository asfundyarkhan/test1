/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package dsa_assignment;
import java.util.*;
/**
 *
 * @author asfund yar khan 
 */
public class DSA_assignment {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Dsa_assignment1 obj= new Dsa_assignment1();
        obj.main_1();
    }
    
}

 class TreeImplementation {
     
     
  public static void b_main() {
        int  flag = 0,i=0;
        Random rand = new Random();
        System.out.println("Enter The length of array :");
        Scanner sc =new Scanner(System.in);
        int x=sc.nextInt();
        int arr[] = new int[x];
        for(i=1; i<arr.length; i++)
        {
            arr[i]=rand.nextInt();
        }
        System.out.print("Enter the element you want to find:");
        int b = sc.nextInt();
        for(i=0; i<arr.length; i++)
        {
            if(arr[i] == b)
            {
                flag = 1;
                break;
            }
            else
            {
                flag = 0;
            }
        }
        if(flag == 1)
        {
            System.out.println("Element found at position:"+(i + 1));
        }
        else
        {
            System.out.println("Element not found");
        }
           
    
    BinaryTree tree = new BinaryTree(arr);
    try
    {
    //In_Order
    
        long start1 = System.currentTimeMillis();
        System.out.print("\nInorder: ");
        tree.inorder();
        long end1 = System.currentTimeMillis();
        System.out.println("");
        System.out.println("Time taken in search is "+(end1-start1)+" miliseconds");
        
    
    //Pre_Order
    
        long start2 = System.currentTimeMillis();
        System.out.print("\nPreorder: ");
        tree.preorder();
        long end2 = System.currentTimeMillis();
        System.out.println("");
        System.out.println("Time taken in search is "+(end2-start2+" miliseconds"));
        
        
    //Post_Order
        System.out.print("\nPostorder: ");
        long start3 = System.currentTimeMillis();    
        tree.postorder();
        long end3 = System.currentTimeMillis();
        System.out.println("");
        System.out.println("Time taken in search is "+(end3-start3)+" miliseconds");
        
    //call the breadth method to test it
    //Breadth First Method
        System.out.print("\nBreadthFirst:");
        long start4 = System.currentTimeMillis();
        tree.breadth();
        long end4 = System.currentTimeMillis();
            System.out.println("");
            System.out.println("Time taken in search is "+(end4-start4)+" miliseconds");
        
        
    }
    
    catch(Exception e)
    {
        System.out.println(e);
    }
    /*finally
            {
                
            }
    */    
  }
}

class BinaryTree {
  private TreeNode root;



  /** Create a default binary tree */
  public BinaryTree() {
  }

  /** Create a binary tree from an array of objects */
  public BinaryTree(int[] objects) {
    for (int i = 0; i < objects.length; i++) {
      insert(objects[i]);
     
    }
  }    // This method mainly calls deleteRec()
    void deleteKey(int element) { root = deleteRec(root, element); }
 
    /* A recursive function to 
      delete an existing key in BST
     */
    TreeNode deleteRec(TreeNode root, int element)
    {
        /*If the tree is empty */
        if (root == null)
            return root;
 
        /* Otherwise, recur down the tree */
        if (element < root.element)
            root.left = deleteRec(root.left, element);
        else if (element > root.element)
            root.right = deleteRec(root.right, element);
 
        // if key is same as root's 
        // key, then This is the
        // node to be deleted
        else {
            // node with only one child or no child
            if (root.left == null)
                return root.right;
            else if (root.right == null)
                return root.left;
 
            // node with two children: Get the inorder
            // successor (smallest in the right subtree)
            root.element = minValue(root.right);
 
            // Delete the inorder successor
            root.right = deleteRec(root.right, root.element);
        }
 
        return root;
    }
 
    int minValue(TreeNode root)
    {
        int minv = root.element;
        while (root.left != null) 
        {
            minv = root.left.element;
            root = root.left;
        }
        return minv;
    }

  /** Search element o in this binary tree */
  public boolean search(int o) {
    return search(o, root);
  }

  public boolean search(int o, TreeNode root) {
    if (root == null) {
      return false;
    }
    if (root.element==0) {
      return true;
    }
    else {
      return search(o, root.left) || search(o, root.right);
    }
  }

  /** Return the number of nodes in this binary tree */
  public int size() {
    return size(root);
  }

  public int size(TreeNode root) {
    if (root == null) {
      return 0;
    }
    else {
      return 1 + size(root.left) + size(root.right);
    }
  }

  /** Return the depth of this binary tree. Depth is the
  * number of the nodes in the longest path of the tree */
  public int depth() {
    return depth(root);
  }

  public int depth(TreeNode root) {
    if (root == null) {
      return 0;
    }
    else {
      return 1 + Math.max(depth(root.left), depth(root.right));
    }
  }

  /** Insert element o into the binary tree
  * Return true if the element is inserted successfully */
  public boolean insert(int o) {
    if (root == null) {
      root = new TreeNode(o); // Create a new root
    }
    else {
      // Locate the parent node
      TreeNode parent = null;
      TreeNode current = root;
      while (current != null) {
        if (((Comparable)o).compareTo(current.element) < 0) {
          parent = current;
          current = current.left;
        }
        else if (((Comparable)o).compareTo(current.element) > 0) {
          parent = current;
          current = current.right;
        }
        else {
          return false; // Duplicate node not inserted
        }
      }

      // Create the new node and attach it to the parent node
      if (((Comparable)o).compareTo(parent.element) < 0) {
        parent.left = new TreeNode(o);
      }
      else {
        parent.right = new TreeNode(o);
      }
    }

    return true; // Element insertion
  }
//  class fpr breadth first
  public void breadth() {
  breadth(root);
  }



//  search traversal
  public void breadth(TreeNode root){
      if (root == null)
          return;
      
  
      System.out.print(root.element + " ");
    
      breadth(root.left);
      breadth(root.right);
 }


  public void inorder() {
    inorder(root);
  }

  //sub tree
  private void inorder(TreeNode root) {
    if (root == null) {
      return;
    }
    
    inorder(root.left);
    System.out.print(root.element + " ");
      
    inorder(root.right);
  }

  // Postorder traversal 
  public void postorder() {
    postorder(root);
  }

  private void postorder(TreeNode root) {
    if (root == null) {
      return;
    }
      
    postorder(root.left);
    postorder(root.right);
    System.out.print(root.element + " ");
    
  }


  public void preorder() {
    preorder(root);
  }

 //subtree
  private void preorder(TreeNode root) {
    if (root == null) {
      return;
    }
    System.out.print(root.element + " ");
      
    preorder(root.left);
    preorder(root.right);

  }

  private class TreeNode {
    int element;
    TreeNode left;
    TreeNode right;

    public TreeNode(int o) {
      element = o;
    }
  }

}

 class Dsa_assignment1 {

    
    
    public static void main_1() {
        
        TreeImplementation obj =new TreeImplementation();
        obj.b_main();
    }
    
}
